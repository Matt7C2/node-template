name: publish-image

on:
  push:
    # Esegue solo sulla push a 'main'
    branches: [ "main" ]
  # Mantiene il trigger per i tag, in caso un utente ne crei uno manualmente
  tags: [ 'v*.*.*' ]
  pull_request:
    branches: [ "main" ]

env:
  REGISTRY: ghcr.io

permissions:
  # Necessario per l'auto-tagging tramite API
  contents: write
  # Necessario per la build e push dell'immagine
  packages: write
  id-token: write

jobs:
  # 1. auto-tag: Crea e pusha il nuovo tag (SOLO su push a 'main')
  auto-tag:
    runs-on: ubuntu-latest
    # Esegue il job solo se l'evento è un push su 'main'
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    
    # L'output del tag sarà usato dal job 'build'
    outputs:
      new_tag: ${{ steps.create_tag.outputs.new_tag }} 

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Necessario per recuperare tutti i tag

      - name: Calculate next tag
        id: calc_tag
        run: |
          latest_tag=$(git tag --sort=-v:refname | head -n 1)
          echo "Latest tag found: $latest_tag"
          if [[ -z "$latest_tag" ]]; then
            # Se nessun tag esiste, inizia da v1.0.0
            new_tag="v1.0.0"
          else
            # Incrementa la patch version (Z)
            # Questo comando incrementa l'ultimo numero (patch)
            new_tag=$(echo $latest_tag | awk -F. '{$NF++; print $1"."$2"."$3}' OFS=. )
          fi
          echo "Generated tag: $new_tag"
          echo "new_tag=$new_tag" >> $GITHUB_OUTPUT # Invia l'output allo step successivo

      # SOLUZIONE ANTI-LOOP: Usa l'API di GitHub per creare il tag.
      # L'uso di github.rest.git.createRef con il GITHUB_TOKEN di default 
      # NON scatena un nuovo workflow.
      - name: Create and push new tag via GitHub API
        id: create_tag
        uses: actions/github-script@v7
        with:
          script: |
            const new_tag = "${{ steps.calc_tag.outputs.new_tag }}";
            console.log(`Attempting to create tag: ${new_tag}`);
            try {
              await github.rest.git.createRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: `refs/tags/${new_tag}`,
                sha: context.sha // Lo SHA del commit che ha scatenato il push
              });
              console.log(`Successfully created and pushed tag: ${new_tag}`);
            } catch (error) {
              // Ignora l'errore 422 se il tag esiste già (es. re-run del workflow)
              if (error.status === 422 && error.response.data.message.includes('Reference already exists')) {
                console.log(`Tag ${new_tag} already exists. Proceeding.`);
              } else {
                throw error;
              }
            }
            // Imposta l'output per il job 'build'
            core.setOutput('new_tag', new_tag); 
          github-token: ${{ secrets.GITHUB_TOKEN }}
        env:
          # Per usare core.setOutput, dobbiamo passare la reference
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # 2. build: Costruisce e pubblica l'immagine
  build:
    needs: auto-tag
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      id-token: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install cosign
        if: github.event_name != 'pull_request'
        uses: sigstore/cosign-installer@v3.5.0
        with:
          cosign-release: 'v2.2.4'

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log into registry ${{ env.REGISTRY }}
        # Esegue il login solo se non è una PR
        if: github.event_name != 'pull_request'
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # LOGICA PIÙ ROBUSTA PER DETERMINARE IL TAG DA USARE
      - name: Determine final image tag
        run: |
          # 1. Priorità al Tag (se il workflow è scatenato da un tag manuale)
          if [[ "${{ github.event_name }}" == "push" && "${{ github.ref }}" == refs/tags/* ]]; then
            TAG_TO_USE="${GITHUB_REF_NAME}"
          # 2. Se è un push a 'main', usa il tag generato dal job 'auto-tag'
          elif [[ "${{ github.event_name }}" == "push" && "${{ github.ref }}" == "refs/heads/main" ]]; then
            # 'needs.auto-tag.outputs.new_tag' è disponibile grazie a 'needs: auto-tag'
            TAG_TO_USE="${{ needs.auto-tag.outputs.new_tag }}"
          # 3. Altrimenti (es. Pull Request), usa un tag basato sullo SHA
          else
            TAG_TO_USE="pr-${GITHUB_SHA::7}"
          fi
          
          IMAGE_NAME_LOWER=$(echo "${GITHUB_REPOSITORY}" | tr '[:upper:]' '[:lower:]')
          TAG_LOWER=$(echo "${TAG_TO_USE}" | tr '[:upper:]' '[:lower:]')
          
          echo "IMAGE_NAME_LOWER=$IMAGE_NAME_LOWER" >> $GITHUB_ENV
          echo "TAG_LOWER=$TAG_LOWER" >> $GITHUB_ENV
          echo "Full image tag: ${{ env.REGISTRY }}/${IMAGE_NAME_LOWER}:${TAG_LOWER}"

      - name: Build and push Docker image
        id: build-and-push
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./docker/Dockerfile
          # Push solo se non è una Pull Request
          push: ${{ github.event_name != 'pull_request' }}
          tags: |
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_LOWER }}:${{ env.TAG_LOWER }}
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_LOWER }}:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      # ... (Cosign signing - puoi scommentarlo quando sei pronto)

  # 3. cleanup: Rimuove le vecchie immagini non utilizzate
  cleanup:
    name: Cleanup old images
    needs: build
    runs-on: ubuntu-latest
    permissions:
      packages: write
      contents: read

    steps:
      - name: Delete old image versions (keep last 3)
        uses: actions/delete-package-versions@v5
        with:
          package-name: ${{ github.event.repository.name }}
          package-type: container
          min-versions-to-keep: 3
          token: ${{ secrets.GITHUB_TOKEN }}
          delete-untagged-versions: true
          days-before-deletion: 0